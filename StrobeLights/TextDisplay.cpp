/*
*  Description:
*  This file provides function to print scrolling text on the screen
*  Color can also be passed
*  Assume the M5Atom has been initialized prior
*/
#pragma once
#include "M5Atom.h"

// Include arrays generated by M5Atom's AtomPixTool (APT)
// https://github.com/m5stack/M5Atom
// Each holds a sequence of characters
#include "characters/AM.c"
#include "characters/NZ.c"
#include "characters/09.c"
#include "characters/amlc.c"
#include "characters/nzlc.c"
#include "characters/exsl.c"
#include "characters/clat.c"

// For Visual Studio debugging
// #include <iostream>
#include <string>
using namespace std;

// Toggle lowercase support
#define USE_LOWER_CASE 1

// Get character data from the APT arrays
// Returns in output5x5 a 5x5 array with 3 colors per each entry
void CharacterExtractor(char a, unsigned char* output5x5) {
  int loc = 0;
  int padding = 2;
  int rowLength = 195; // 15 * (26 / 2)

  // Determine location to read the character
  if (a == 32) {
    for (int i = 0; i < 75; i++) output5x5[i] = 0;
    return;
  }
 else if (a >= 33 && a <= 47) {
    loc = 15 * (a - 33);
    rowLength = 225; // 15 * 15
  }
  else if (a >= 48 && a <= 57) {
    loc = 15 * (a - 48);
    rowLength = 150; // 15 * 10
  }
  else if (a >= 58 && a <= 64) {
    loc = 15 * (a - 58);
    rowLength = 105; // 15 * 7
  }
  else if (a >= 65 && a <= 77) loc = 15 * (a - 65);
  else if (a >= 78 && a <= 90) loc = 15 * (a - 78);
  else if (a >= 97 && a <= 109) loc = 15 * (a - 97);
  else if (a >= 110 && a <= 122) loc = 15 * (a - 110);

  for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
      // Reduce computation
      unsigned int tempIndex = padding + i * rowLength + loc + 3 * j;

      // Debugging purposes
      unsigned char bb = 0;

      for (int k = 0; k < 3; k++) {
        unsigned char temp = 0;
        if (a >= 33 && a <= 47) temp = image_exsl[tempIndex + k];
        else if (a >= 48 && a <= 57) temp = image_09[tempIndex + k];
        else if (a >= 58 && a <= 64) temp = image_clat[tempIndex + k];
        else if (a >= 65 && a <= 77) temp = image_AM[tempIndex + k];
        else if (a >= 78 && a <= 90) temp = image_NZ[tempIndex + k];
        else if (a >= 97 && a <= 109) temp = image_amlc[tempIndex + k];
        else if (a >= 110 && a <= 122) temp = image_nzlc[tempIndex + k];
        output5x5[i * 15 + j * 3 + k] = temp;
        bb += temp;
      }
      // if (bb) cout << "0 ";
      // else cout << "  ";
    }
    // cout << endl;
  }
  // cout << endl;
  return;
}

// Bridge between two characters, output via output5x5 (array of 25 positions)
// Step is the number of units that the characters have moved (to the left, minimum 0, maximum dependent on type)
// Type is the type of two characters: AA: 0, Aa: 1, aA: 2, aa: 3
// AA: steps 0-5, Aa/aA: steps 0-4, aa: steps 0-3
void BridgeCharacters(unsigned char* a5x5, unsigned char* b5x5, unsigned char* output5x5, unsigned char step, unsigned char type) {
  // Determine location of space
  unsigned char spaceLoc = 0;
  if (type == 0 || type == 1) spaceLoc = 5 - step;
  else spaceLoc = 4 - step;

  for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
      // Debugging purposes
      unsigned char bb = 0;

      for (int k = 0; k < 3; k++) {
        if (type == 0 || type == 1) {
          // If beyond space display second character
          if (j > spaceLoc) output5x5[15 * i + 3 * j + k] = b5x5[15 * i + 3 * (j - spaceLoc - 1) + k];

          // Otherwise display first character
          else if (j < spaceLoc) output5x5[15 * i + 3 * j + k] = a5x5[15 * i + 3 * (j + step) + k];
          else output5x5[15 * i + 3 * j + k] = 0;
        }
        else {
          if (j > spaceLoc) output5x5[15 * i + 3 * j + k] = b5x5[15 * i + 3 * (j - spaceLoc - 1) + k];
          else if (j < spaceLoc) output5x5[15 * i + 3 * j + k] = a5x5[15 * i + 3 * (j + step) + k];
          else output5x5[15 * i + 3 * j + k] = 0;
        }
        bb += output5x5[15 * i + 3 * j + k];
      }
      // if (bb) cout << "0 ";
      // else cout << "  ";
    }
    // cout << endl;
  }
  // cout << endl;
  return;
}

// Add color to 5x5 3-color array
void Colorize5x5(unsigned char* output5x5, unsigned char R, unsigned char G, unsigned char B) {
  for (int i = 0; i < 75; i+=15) {
    for (int j = 0; j < 15; j+=3) {
      bool bb = false;
      for (int k = 0; k < 3; k++) if (output5x5[i + j + k] != 0) bb = true;
      if (bb) {
        output5x5[i + j] = R;
        output5x5[i + j + 1] = G;
        output5x5[i + j + 2] = B;
      }
    }
  }
}

// Check if character is lowercase
bool isLowercase(char a) {
  // Numbers & symbols included in uppercase
  if (a >= 33 && a <= 90) return false;
  else if (a >= 97 && a <= 122) return true;
  return false;
}

// Add x-y padding
// This is needed because of M5Atom's awful choice of adding the size of the array into the array itself
// NOTE: this output5x5 has 77 locations
void AddPadding(unsigned char* output5x5, unsigned char x, unsigned char y) {
  for (int i = 74; i >= 0; i--) output5x5[i + 2] = output5x5[i];
  output5x5[0] = x;
  output5x5[1] = y;
}

void RemovePadding(unsigned char* output5x5) {
  for (int i = 0; i < 75; i++) output5x5[i] = output5x5[i + 2];
}

// Function responsible for creating the scrolling text effect
// A string is passed, with characterDuration (seconds) representing how long a character takes to move across
// 8-bit color is passed (RGB)
void TextDisplay(const string& s, float characterDuration, unsigned char R, unsigned char G, unsigned char B) {
  unsigned char** dualChars = new unsigned char*[2];
  dualChars[0] = new unsigned char[75];
  dualChars[1] = new unsigned char[75];

  long startMilli = millis();
  int padding = 2;
  unsigned char* output5x5 = new unsigned char[75 + padding];
  
  // This order will flip between 0 and 1, changing which of the dualchars is first
  unsigned char order = 0;
  string temp;
  unsigned char type;
  if (s.length() > 0) {
    CharacterExtractor(s[0], dualChars[0]);
    if (isLowercase(s[0])) type = 2;
    else type = 0;

    for (int i = 1; i < s.length() + 1; i++) {
      type++;
      if (i < s.length()) {
        CharacterExtractor(s[i], dualChars[1 - order]);
        if (!isLowercase(s[i])) type--;
      }
      // Move the final character away
      else CharacterExtractor(' ', dualChars[1 - order]);

      for (unsigned char j = 0; j < 6 - (type + 1) / 2; j++) {
        BridgeCharacters(dualChars[order], dualChars[1 - order], output5x5, j, type);
        Colorize5x5(output5x5, R, G, B);
        AddPadding(output5x5, 5, 5);
    
        // Display the array
        M5.dis.displaybuff(output5x5, 0, 0);
        M5.update();
        startMilli = millis();
        while (millis() < startMilli + characterDuration * 200) {
          // Break if the button is pressed
          // if (M5.Btn.wasPressed()) break;
        }
        
        // Break if the button is pressed
        // if (M5.Btn.wasPressed()) break;
      }

      // Break if the button is pressed
      // if (M5.Btn.wasPressed()) break;

      // Next step preparation
      if (isLowercase(s[i])) type = 2;
      else type = 0;
      order = 1 - order;
    }
  }
  
  // Clear the screen
  M5.dis.fillpix(0x000000);
  M5.update();
  
  // Delete allocated arrays
  delete[] dualChars[0];
  delete[] dualChars[1];
  delete[] dualChars;
  delete[] output5x5;
}

// Cubic interpolation between a and b by t in range [0, 1]
float cubicInterpolate(float a, float b, float t) {
  return (b - a) * (-2 * t + 3) * t * t + a;
}

// Function to display a single character
// characterDuration (seconds) representing how long the character lasts
// Fade still being added
void CharacterDisplay(char a, float characterDuration, unsigned char R, unsigned char G, unsigned char B,
    bool fadeIn, bool fadeOut, float fadeDuration, bool keep) {
  // This is needed because of M5Atom's awful choice of adding the size of the array into the array itself
  int padding = 2;
  unsigned char* a5x5 = new unsigned char[75 + padding];

  // Create array 
  CharacterExtractor(a, a5x5);

  unsigned char tempR = 0, tempG = 0, tempB = 0;
  long startMilli = millis();
  float frac = 0;
  
  if (fadeIn) while (millis() < startMilli + fadeDuration * 1000) {
    frac = (millis() - startMilli) * 1.0 / (fadeDuration * 1000);
    tempR = round(cubicInterpolate(0, R, frac));
    tempG = round(cubicInterpolate(0, G, frac));
    tempB = round(cubicInterpolate(0, B, frac));
    if (tempR > 0 || tempG > 0 || tempB > 0) {
      Colorize5x5(a5x5, tempR, tempG, tempB);
      AddPadding(a5x5, 5, 5);
      // Display the array
      M5.dis.displaybuff(a5x5, 0, 0);
      M5.update();
      RemovePadding(a5x5);
    }
  }

  Colorize5x5(a5x5, R, G, B);
  AddPadding(a5x5, 5, 5);
  
  // Display the array
  M5.dis.displaybuff(a5x5, 0, 0);
  M5.update();
  startMilli = millis();
  while (millis() < startMilli + characterDuration * 1000) {
    // Break if the button is pressed
    // if (M5.Btn.wasPressed()) break;
  }

  startMilli = millis();
  RemovePadding(a5x5);
  frac = 1;

  if (fadeOut && !keep) while (millis() < startMilli + fadeDuration * 1000) {
    frac = (millis() - startMilli) * 1.0 / (fadeDuration * 1000);
    // This time around no need to worry about zeroing the array
    tempR = round(cubicInterpolate(R, 0, frac));
    tempG = round(cubicInterpolate(G, 0, frac));
    tempB = round(cubicInterpolate(B, 0, frac));
    if (tempR > 0 || tempG > 0 || tempB > 0) {
      Colorize5x5(a5x5, tempR, tempG, tempB);
      AddPadding(a5x5, 5, 5);
      // Display the array
      M5.dis.displaybuff(a5x5, 0, 0);
      M5.update();
      RemovePadding(a5x5);
    }
  }
    
  // Clear the screen
  if (!keep) {
    M5.dis.fillpix(0x000000);
    M5.update();
  }
  delete[] a5x5;
}
